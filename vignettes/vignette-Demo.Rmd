---
title: "vignette-Demo"
author: "Xutao Wang"
date: "5/19/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r libraries, message=FALSE}
library(BiocParallel)
library(dplyr)
library(ggplot2)
library(ggridges)
library(gridExtra)
library(MultiAssayExperiment)
library(SummarizedExperiment)
library(TBSignatureProfiler)

devtools::load_all()
library(curatedTBData)
```

# `curatedTBData`: Clinically Annotated Data for the Tuberculosis (TB) Transcriptome
## Load available TB studies in the form of MultiAssayExperiemnt Objects

We use `MultiAssayExperiemnt` object to store information all available datasets. The pakcage function `curatedTBData` takes single or vector character string of Gene Expression Omnibus (GEO) accession as an input, and load the correpsonding curatedTBData.

```{r load a list of all datasets, results='hide', message=FALSE}
# To get a summary table for all the studies:
data("DataSummary", package = "curatedTBData")
View(DataSummary)
DataSummary$`GEO accession`[-nrow(DataSummary)]
# Get a list of all data 
###### The following command takes about 5 miniutes
objects_list <- curatedTBData(geoAccession = "All")

# Load single data
# curatedTBData("GSE39939")

# Load Multiple Studies
# SuperSeries is composed of the 5 SubSeries for Blood Transcriptional Profiles in Human Active and Latent Tuberculosis:
GSE19491 <- c("GSE19435", "GSE19439", "GSE19442", "GSE19444", "GSE22098")
GSE19491_list <- curatedTBData(GSE19491)
GSE19491_list
colData(GSE19491_list[[1]])
```
```{r}
# Every study should contain TBStatus
lapply(objects_list, function(x) colData(x)[, "TBStatus"]) %>% unlist() %>% table()
```


## Load all of the RNA-seq data
```{r load a list of RNA-seq studies, results='hide', eval=FALSE}
geo_RNA_seq <- DataSummary %>% 
  dplyr::filter(stringr::str_detect(.data$GeneralType, "RNA-seq")) %>%
  dplyr::select(.data$`GEO accession`) %>% 
  unlist(use.names = FALSE)
length(geo_RNA_seq)
# object_list_RNA_seq <- curatedTBData(geo_RNA_seq$`GEO accession`)
```

## Load all of the Microarray data
```{r load a list of microarray studies, results='hide', eval=FALSE}
geo_microarray <- DataSummary %>% 
  dplyr::filter(stringr::str_detect(.data$GeneralType, "Microarray")) %>%
  dplyr::select(.data$`GEO accession`) %>% 
  unlist(use.names = FALSE)
length(geo_microarray)
# object_list_microarray <- curatedTBData(geo_RNA_seq$`GEO accession`)
# The remaining one is RT-PCR study
```

# Subset Objects

## Subset based on TBStatus
The major adavantage of using `SummarizedExperiment` and `MultiAssayExperiment` is the coordination of the meta-data and assays when subsetting.
Both SummarizedExperiment and MultiAssayExperiment objects have similar buil-in fuction for subset samples based on column condition. For example, we want to select samples with only active TB, or with PTB or OD.
```{r subsetting single object example}
# subset samples from objects with TBStatus: PTB
AndersonData <- objects_list$GSE39939 # 157 samples
AndersonData
AndersonData[, AndersonData$TBStatus == "PTB"] # 79 samples
AndersonData[, AndersonData$TBStatus %in% c("LTBI","OD")] # 78 samples
```

## Subset based on HIVStatus
```{r, message=FALSE}
object_match_HIV <- lapply(objects_list, function(x)
  check_annotation(x, annotationColName = "HIVStatus", 
                   annotationCondition = "Positive")) %>% plyr::compact()
length(object_match_HIV)
object_match_HIV
```

## Subset based on DiabetesStatus
```{r, message=FALSE}
object_match_DM <- lapply(objects_list, function(x)
  check_annotation(x, annotationColName = "DiabetesStatus", 
                   annotationCondition = "Positive")) %>% plyr::compact()
# 2 studies
```

## Longitidinal Study (Subset samples at certain time point)
There are some studies that included repeated measurement of the same subjects, which study gene expression change in repsonse to treatment or from non-progressor to progressor.
```{r}
ACS_cohort <- objects_list$GSE79362 # adolescents progression from LTBI to tuberculosis disease during 2 years.
ACS_cohort$Progression %>% table # 355 samples
sample_baseline <- colData(ACS_cohort)[, c("PatientID", "MeasurementTime")] %>%
  data.frame() %>%
  mutate(sample_name = row.names(colData(ACS_cohort))) %>%
  dplyr::arrange(MeasurementTime, PatientID) %>%
  dplyr::group_by(PatientID) %>%
  dplyr::mutate(first = dplyr::first(sample_name))
GSE79362_baseline <- ACS_cohort[,unique(sample_baseline$first)]
GSE79362_baseline$Progression %>% table() # 144 patients were infected with Mycobacterium tuberculosis
```

# Datasets Integration

## Merge Studies with common gene symbols
If datasets are merged, it is typically recommended to remove a very likely batch effect. We will use the ComBat method, implemented for example in the SVA Bioconductor package. Start using `CombineObjects` to intersect objects with common gene symbol. This function produces a SummarizedExperiment object. GSE74092 is usually removed from merging, because this study used quantitative PCR so they did not have enough coverage to capture most of the genes.

```{r merge datasets, results="hide"}
# Merge seletced studies
Anne_OGarra_study <- c("GSE107991", "GSE107992", "GSE107993", "GSE107994")
sobject <- CombineObjects(objects_list, 
                          list_name = Anne_Garra_study, 
                          experiment_name = "assay_curated")

sobject
```

```{r}
# Create a table for sample and data source information with:
sample_data_info <- data.frame(Sample = row.names(colData(sobject)), 
                               GSEStudy = colData(sobject)[,"GSE"],
                               TBStatus = colData(sobject)[,"TBStatus"])
sample_data_info
```

## Batch Correction
```{r batch correction, results='hide'}
# The samples that correspond to their datasets can be found at: colData(sobject)[,"GSE"]
# Batch correction, each study is viewed as one batch
batch1 <- colData(sobject)$GSE

combat_edata1 <- sva::ComBat(dat = as.matrix(assay(sobject)), batch = batch1)
# Add the batch corrected data to the original summarizedExperiment
SummarizedExperiment::assays(sobject)[["Batch_corrected_data"]] <- combat_edata1
sobject
# To separate batch-corrected object into separate SummarizedExperiment object list:
batch_sobject_list <- lapply(unique(colData(sobject)[,"GSE"]), function(x) {
  index_GSE <- which(colData(sobject)$GSE %in% x)
  sobject[,index_GSE]
})
names(batch_sobject_list) <- unique(colData(sobject)[,"GSE"])
batch_sobject_list

```

# Active TB (PTB) vs. LTBI using `TBSignatureprofiler`
```{r}
multi_set_PTB_Latent <- mclapply(objects_list, function(x)
  subset_curatedTBData(x, annotationColName = "TBStatus", 
                       annotationCondition = c("LTBI","PTB"), 
                       experiment_name = "assay_curated"), 
                       mc.cores = 6) %>% plyr::compact()
length(multi_set_PTB_Latent) # 22 datasets
multi_set_PTB_Latent_sub <- multi_set_PTB_Latent[1:5]
# Remove empty objects using plyr::compact()
TBsignatures <- TBsignatures[1:5]
ssgsea_PTB_Latent <- lapply(multi_set_PTB_Latent_sub,
                    function(x) TBSignatureProfiler::runTBsigProfiler(
                                  input = x,
                                  useAssay = assayNames(x),
                                  signatures = TBsignatures, 
                                  algorithm = "ssGSEA",
                                  combineSigAndAlgorithm = TRUE))
ssgsea_PTB_Latent
# Obtain p.value, AUC, and Bootstrapped Confidence Interval
ssgsea_PTB_Latent_combine <- combine_auc(ssgsea_PTB_Latent, 
                                annotationColName = "TBStatus", 
                                signatureColNames = names(TBsignatures), 
                                num.boot = 1000, percent = 0.95)
ssgsea_PTB_Latent_combine
```
