---
title: "curatedTBData"
author: "Xutao Wang"
output: BiocStyle::html_document
vignette: >
  %\VignetteIndexEntry{curatedTBData}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache.lazy = FALSE)
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
if (! "BiocParallel" %in% installed.packages()) BiocManager::install("BiocParallel")
if (! "SummarizedExperiment" %in% installed.packages()) BiocManager::install("SummarizedExperiment")
if (! "MultiAssayExperiment" %in% installed.packages()) BiocManager::install("MultiAssayExperiment")
if (! "limma" %in% installed.packages()) install.packages("plyr")
if (! "GEOquery" %in% installed.packages()) BiocManager::install("GEOquery")
if (! "dplyr" %in% installed.packages()) install.packages("dplyr")
if (! "plyr" %in% installed.packages()) install.packages("plyr")
if (! "TBSignatureProfiler" %in% installed.packages()) devtools::install_github("aubreyodom/TBSignatureProfiler")
```

```{r install curatedTBData, eval = FALSE}
devtools::install_github("xutao-wang/curatedTBData")
```

```{r libraries, message=FALSE}
# Alphabetic order
library(BiocParallel)
library(dplyr)
library(edgeR)
library(GEOquery)
library(ggplot2)
library(ggridges)
library(gridExtra)
library(illuminaHumanv4.db) # Illumina HumanHT-12 V4.0 expression beadchip
library(limma)
library(MultiAssayExperiment)
library(plyr)
library(SummarizedExperiment)
library(sva)
library(TBSignatureProfiler)


# library(magick)
# Load probe db

library(curatedTBData)
```


# `curatedTBData`: Clinically Annotated Data for the Tuberculosis (TB) Transcriptome

Insert introduction/background infrmation about this data package

# Create SummarizedExperiment/MultiAssayExperiment Object

# Load available SummarizedExperiment/MultiAssayExperiment Objects

We use `SummarizedExperiment` object to store information for microarray datasets, and use `MultiAssayExperiment` object to store information for RNA sequencing datasets

```{r load list of sobject, message=FALSE}
# Load the pacakge
list_files <- data(package="curatedTBData")[["results"]][,"Item"]

# Get a list of all data
data(list=list_files) 
strobject <- ls(pattern="*object$")

# Create a list for loaded data for metadata analysis
objects_list <- lapply(strobject, function(x) get(x)) # Takes some time...
objects_name <- gsub("_.*","",strobject)
names(objects_list) <- objects_name

## Create summary table for data with their sequencing platform
rna_seq_name <- which(sapply(objects_list, function(x) class(x)) == "MultiAssayExperiment") %>% names()
microarray_name <- which(sapply(objects_list, function(x) class(x)) != "MultiAssayExperiment") %>% names()
data_type <- data.frame(GSE = c(rna_seq_name,microarray_name), Type = c(rep("RNA-seq",length(rna_seq_name)),rep("Microarray",length(microarray_name))), stringsAsFactors = F)
index_norm <- which(data_type$GSE %in% c("GSE54992","GSE36238","GSE31348","GSE73408","GSE41055" ,"GSEXXXXX"))

data_type[index_norm,"Type"] <- "NormalizedMicroarray"
```

# Subsetting Objects

The major adavantage of using `SummarizedExperiment` and `MultiAssayExperiment` is the coordination of the meta-data and assays when subsetting.

## Subsetting for single objects

Both objects have similar method used for subsetting column information. For example, we want to select samples with only active TB
```{r}
# subsetting samples from objects with TBStatus: PTB
GSE39939_sobject[, GSE39939_sobject$TBStatus == "PTB"]
# subsetting samples from objects with TBStatus: PTB
GSE107991_mobject[, GSE107991_mobject$TBStatus == "PTB"]
```

## Subsetting for multiple objects based on multiple conditions

Since not all datasets contain information for each TB status. Next we want to select out objects that contain samples with only positive TB (PTB) and latent TB (Latent). In this case, we can use `SubsetSample` function from curatedTBData. For either a list of datasets or a single dataset. 
```{r, warning=FALSE}
objects_list_test <-  lapply(objects_list, function(x)
  SubsetTBStatus(x,"TBStatus",c("Latent","PTB"), experiment_type = "all")) %>% plyr::compact() 

# 21/42 objects contain samples from PTB and Latent
length(objects_list_test) 
```

# Normalization

For imported expression datasets other than affymetrix microarray and GSEXXXXX, they are all non-normalized raw data. Next, we normalize microarray data using `normalizeBetweenArrays` from `limma` package , and normalize RNA-seq data using `TMM` from `edgeR` package before matching probesets to gen symbol. 
Steps take: 
1. remove outliers using `arrayQualityMetrics`.??? Have not included yet
2. Set intensity values < 10 set to 10
3. log2 transformed the data.
4. Normalize data (RMA for Affymetrix microarray, quantile normalization for other microarray).

## Between-sample normalization for Illumina microarray

```{r}
# add the normalized data as a new assay in the SummarizedExperiment 
# set all counts less than 0 to be 1
GSE39939_sobject_norm <- Normalization(GSE39939_sobject, method = "quantile")
```
Boxplot for non-normalized microarray data
```{r, fig.height = 8, fig.width = 8}
boxplot(log(assays(GSE39939_sobject_norm)[["GSE39939_Non_normalized_counts"]][,1:20], base=2))
# display the boxplot in log2 for selected samples
```
Boxplot for microarray data after quantile normalization
```{r, fig.height = 8, fig.width = 8}
boxplot(assays(GSE39939_sobject_norm)[["NormalizedData"]][,1:20])
# display the boxplot in log2 for selected samples
```

## Betwwen-sample normalization for RNA-seq

```{r}
# Add the normalized data as a new assay in the MultiAssayExperiment. 
# Use experiment_type = "assay_reprocess" for reprocess RNA-seq
GSE107991_mobject_norm <- Normalization(GSE107991_mobject, experiment_type = "assay_raw", method = "TMM")
```

Boxplot for non-normalized RNA-seq data
```{r, fig.height = 8, fig.width = 8}
# display the boxplot in log2
boxplot(log(assay(experiments(GSE107991_mobject_norm)[["assay_raw"]])[,1:20]+0.0001, base = 2))
```

Boxplot for normalized RNA-seq data
```{r, fig.height = 8, fig.width = 8}
# display the boxplot in log2
# TMM reduces maximum value
boxplot(assays(experiments(GSE107991_mobject_norm)[["assay_raw"]])[["NormalizedData"]][,1:20])
```

# Match ProbeID to Gene symbol

For objects that contain probe information, we match them to gene symbol. We collapse probe information by taking their mean values if they mapped to the same gene, and expand probe information for non-uniqueness mapping. In such cases, we use MultiAssayExperiment Objects to store information for each data.

```{r}
# Match Probe ID using raw data
# Specificy experiment_type = "assay_raw_norm" fo matching probe ID using normalized data (if applicable)
MatchProbe(GSE39939_sobject, experiment_type = "assay_raw")
MatchProbe(GSE107991_mobject, experiment_type = "assay_raw")
```

# TBSignature Analysis 
First of all, we create reate a list of object with normalized reads and probesets mapped to symbols. Match probe ID to symbol using either raw data or normalized data (if applicable) .
Matching probes to symbol using raw data is straight-forward, we use the normalized data in the following.

```{r normalized/matched sample, cache=TRUE, message=FALSE}
# Normalization. For RNA-seq data, we use raw data from online for normalization (Not the self-processed data)
# Use online raw data by specifying the experiment_type=assay_raw
object_norm <- lapply(objects_list, function(x) Normalization(x, experiment_type = "assay_raw")) 

# Match Probe to gene symbols
# Use the normalized data from assay_raw by specifying the experiment_type=assay_raw_norm
object_match1 <- lapply(object_norm, function(x) MatchProbe(x, experiment_type = "assay_raw_norm"))

# Remove samples with TBStatus == NA
object_match <- lapply(object_match1, function(x) x[,colData(x)[,"TBStatus"]!= "NA"])
```

## Active TB (PTB) vs. Latent TB (Latent) using `TBSignatureprofiler`{.tabset}
`TBSignatureprofiler` is a package to evaluate the the performance of signatures across curated TB data. We subset samples with PTB and Latent TB status for binary classification using function `SubsetSample`, and implement Single-sample Gene Set Enrichment Analysis (ssGSEA) scoring algorithm to compute gene scores for each signature.
Workflow of ssGSEA:
1. Input data, take sample-specific absolute rank.
2. After getting the ranked data, calculate random walk statistics for each sample. p: Number of genes, j: sample, k:gene set
$$v_{jk}(\ell)=\frac{\sum_{i=1}^\ell r_{ij}^\tau I(g(i)\in\gamma_k)}{\sum_{i=1}^pr_{ij}^\tau I(g(i)\in\gamma_k)}-\frac{\sum_{i=1}^\ell I(g(i)\notin \gamma_k)}{p-|\gamma_k|}, \quad\ell=1,\dots,p \\
ES_{jk}=\sum_{\ell=1}^p v_{jk}(\ell)$$
3. Re-scale the enrichment scores (ES) for each sample
$$\frac{ES_{jk}}{\max(ES_{jk})-\min(ES_{jk})}, j=1,\dots,n$$
```{r calculate ssgsea for PTB vs Latent, cache=TRUE, message = FALSE, warning = FALSE, results = "hide"}
# Select sample contain information about PTB and Latent
# Modify the list to make it compatible with TBSignatureProfiler

multi_set_PTB_Latent <- lapply(object_match, function(x)
  SubsetTBStatus(x,"TBStatus",c("Latent","PTB"), experiment_type="assay_reduce")) %>% plyr::compact() 
# Remove empty objects use plyr::compact()

ssgsea_PTB_Latent <- lapply(multi_set_PTB_Latent,
                    function(x) TBSignatureProfiler::runTBsigProfiler(input = x,
                                  useAssay = assayNames(x),
                                  signatures = TBsignatures, 
                                  algorithm = "ssGSEA",
                                  combineSigAndAlgorithm = TRUE,
                                  parallel.sz = 12))

# Get signatures with only scores and disease status
# TBSignature, a list of desired signarure signature 
ssgsea_PTB_Latent1 <- SignatureFilter(ssgsea_PTB_Latent, TBsignatures, annotationColName="TBStatus")
```

### Boxplot of all scores signatures{.tabset}

```{r Boxplot for each signature PTB vs. Latent, results = "asis", message = FALSE, fig.height = 25, fig.width=28}
for (i in names(TBsignatures)){

  cat("####", i, "\n")
  
  BoxplotTBSig(ssgsea_PTB_Latent1, gset = i, annotationName = "TBStatus")
  #print(signatureBoxplot(ssgsea_result, name = i, signatureColNames = i,
  #               annotationColName = c("Disease")))
  
  cat("\n\n")
}
```

### Comparing Signature Scores via AUCs

```{r AUC ridge plot for PTB vs Latent,fig.height = 15, fig.width=8, message=FALSE}
# Combine results from ssgsea_PTB_Latent
ssgsea_PTB_Latent_combine <- combine_auc(ssgsea_PTB_Latent, gset = TBsignatures)

# Ridge plot for AUCs distribution across datasets
# PTB vs. Latent
get_auc_distribution(ssgsea_PTB_Latent_combine) + ggtitle("Ridge plot of AUC for PTB vs. Latent")
```

## Molecular Degree of Perturbation Analysis
Molecular Degree of Perturbation (MDP) is a method to standardized gene expression data to the refernce (control). First of all, we subset the lists that contain samples with TBStatus: Control.
```{r MDP, cache=TRUE, message=FALSE}
MDP_control_name <- lapply(object_match, function(x) 
  x[,x$TBStatus == "Control"]) %>% remove_empty_object() %>% names()
MDP_control <- object_match[MDP_control_name] # study includes control samples

MDP_result <- lapply(1:length(MDP_control), function(x) MDP(MDP_control[[x]], gset = TBsignatures, experiment_type = "assay_reduce", assay_name = 1, GSE = names(MDP_control)[x]))

# Use the original methods by selecting top 25% genes
MDP_result_NULL <- lapply(1:length(MDP_control), function(x) MDP(MDP_control[[x]], gset = NULL, experiment_type = "assay_reduce", assay_name = 1, GSE = names(MDP_control)[x]))
```

### Boxplot for MDP{.tabset}

```{r, results = "asis", message = FALSE, fig.height = 28, fig.width=30}
for (i in names(TBsignatures)){

  cat("####", i, "\n")
  
  BoxplotTBSig(MDP_result, gset = i, annotationName = "TBStatus")
  
  cat("\n\n")
}
```

#### Default 

```{r, results = "asis", message = FALSE, fig.height = 28, fig.width=30}
BoxplotTBSig(MDP_result_NULL, gset = "sMDP", annotationName = "TBStatus")
# sMDP is the annotation column name from MDP_result_NULL
```

# Integration of RNA-Seq data with microarray data for TB profiling

## Batch Correction with ComBat

If datasets are merged, it is typically recommended to remove a very likely batch effect. We will use the ComBat method, implemented for example in the SVA Bioconductor package. Start using `CombineObjects` to intersect objects with common gene symbol. This function produces a SummarizedExperiment object.
```{r, message=FALSE}
# Select the objects you want to combine
# Randomly pick 2 from RNA-seq,2 from microaray
result <- CombineObjects(object_match, gse_name=c("GSE101705","GSE107104", "GSE54992", "GSE19444"), experiment_type="assay_reduce") 
# output is a SummarizedExperiment Object

# Batch Correction
mod1 <- model.matrix(~as.factor(TBStatus), data=colData(result))
batch1 <- colData(result)$GSE
combat_edata1 <- sva::ComBat(dat=assays(result)[[1]], batch=batch1, mod=mod1)

# Add batch corrected data as a new assay to the orginal SummarizedExperiment
assays(result)[["BacthCorrect"]] <- combat_edata1
```

Boxplot before Batch correction

```{r, fig.width=8, fig.height=6, warning=FALSE}
boxplot(assays(result)[[1]])
```

Boxplot after Batch correction
```{r, fig.width=8, fig.height=6, warning=FALSE}
# log 2
boxplot(assays(result)[[2]])
```

## Molecular Degree of Perturbation (MDP) for Batch Corrected Data
Recall the list of studies that have control samples. We could either pick up some data from the data for batch correction or use all of them. Next we will use all the available 21 studies. Function `CombineObjects` enables us to combine studies from different sources/platforms by intersecting commone genes from each dataset. The output data can be used for batch correction.
```{r Batch corrected of MDP/ssGSEA, cache=TRUE, message=FALSE, warning=FALSE}
# Batch correction
# remove GSE74092 becuase it only has about matched gene symbol
MDP_batch <- CombineObjects(object_match, gse_name = MDP_control_name[-which(MDP_control_name %in% "GSE74092")]) 

# Batch Correction
mod1 <- model.matrix(~as.factor(TBStatus), data=colData(MDP_batch))
batch1 <- colData(MDP_batch)$GSE
combat_edata1 <- sva::ComBat(dat=assays(MDP_batch)[[1]], batch=batch1, mod=mod1)

# Add batch corrected data as a new assay to the orginal SummarizedExperiment
assays(MDP_batch)[["BacthCorrect"]] <- combat_edata1

# Calculate MDP for batch correct object
MDP_batch_result <- MDP(theObject = MDP_batch, gset = TBsignatures, assay_name = "BacthCorrect")

# Calculate ssGSE for batch correct object
MDP_batch_ssgsea <- TBSignatureProfiler::runTBsigProfiler(input = MDP_batch,
                                  useAssay = "BacthCorrect",
                                  signatures = TBsignatures, 
                                  algorithm = "ssGSEA",
                                  combineSigAndAlgorithm = TRUE,
                                  parallel.sz = 12)
```

### Boxplot for Batch Corrected MDP

```{r, cache=TRUE, results = "asis", message = FALSE, warning = FALSE, fig.height = 32, fig.width=32}
# 5 levels of TBStatus: Control/Laent/OD/PTB
# Create SummarizedExperiment Object to make it compaticble with the function
MDP_batch_result$TBStatus <- factor(MDP_batch_result$TBStatus, levels = c("Control", "Latent", "PTB", "OD"))
myColors <- RColorBrewer::brewer.pal(4,"Set1")
names(myColors) <- levels(MDP_batch_result$TBStatus)
              
TBSignatureProfiler::signatureBoxplot(
               inputData = SummarizedExperiment(colData = MDP_batch_result),
               name = "Boxplot for Batch Corrected MDP",
               signatureColNames = colnames(MDP_batch_result)[-ncol(MDP_batch_result)],
               annotationColName = "TBStatus",
               rotateLabels = FALSE,
               fill_colors = myColors)
```

### Boxplot for batch corrected ssGSEA
```{r, results = "asis", message = FALSE, warning = FALSE, fig.height = 32, fig.width=32}
index <- grep("Sloot_HIV_2|Suliman_RISK_4", names(TBsignatures))
TBSignatureProfiler::signatureBoxplot(
                        inputData = SummarizedExperiment(colData = colData(MDP_batch_ssgsea)),
                                name = "Boxplot for Batch Corrected MDP",
                                signatureColNames = names(TBsignatures)[-index],
                                annotationColName = "TBStatus",
                                rotateLabels = FALSE,
                                fill_colors = myColors)

```

