---
title: "curatedTBData"
author: "Xutao Wang"
output: BiocStyle::html_document
vignette: >
  %\VignetteIndexEntry{curatedTBData}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache.lazy = FALSE)
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
if (! "SummarizedExperiment" %in% installed.packages()) BiocManager::install("SummarizedExperiment")
if (! "MultiAssayExperiment" %in% installed.packages()) BiocManager::install("MultiAssayExperiment")
if (! "limma" %in% installed.packages()) install.packages("plyr")
if (! "GEOquery" %in% installed.packages()) BiocManager::install("GEOquery")
if (! "dplyr" %in% installed.packages()) install.packages("dplyr")
if (! "plyr" %in% installed.packages()) install.packages("plyr")
if (! "TBSignatureProfiler" %in% installed.packages()) devtools::install_github("aubreyodom/TBSignatureProfiler")
```

```{r libraries, message = FALSE}
library(GEOquery)
library(SummarizedExperiment)
library(MultiAssayExperiment)
library(limma)
library(edgeR)
library(dplyr)
library(plyr)

library(TBSignatureProfiler)
library(ggplot2)
library(gridExtra)
library(ggridges)

# library(magick)
# Load probe db
library(illuminaHumanv4.db) # Illumina HumanHT-12 V4.0 expression beadchip

devtools::load_all(".")
library(curatedTBData)
```
# `curatedTBData`: Clinically Annotated Data for the Tuberculosis (TB) Cancer Transcriptome
Insert introduction/background infrmation about this data package
# Using SummarizedExperiment/MultiAssayExperiment Object
Insert how you get these objects from the beginnig 
```{r}

```

# Load list of existing SummarizedExperiment/MultiAssayExperiment Objects
We use `SummarizedExperiment` object to store information for microarray datasets, and use `MultiAssayExperiment` object to store information for RNA sequencing datasets
```{r load list of sobject, message=FALSE}
# Load the pacakge
list_files <- data(package="curatedTBData")[["results"]][,"Item"]

# Get a list of all data
data(list=list_files) # Takes some time...
strobject <- ls(pattern="*object$")

# Create a list for loaded data for metadata analysis
objects_list <- lapply(strobject, function(x) get(x))
names(objects_list) <- gsub("_.*","",strobject)

rna_seq_name <- which(sapply(objects_list, function(x) class(x)) == "MultiAssayExperiment") %>% names()
microarray_name <- which(sapply(objects_list, function(x) class(x)) != "MultiAssayExperiment") %>% names()
data_type <- data.frame(GSE = c(rna_seq_name,microarray_name), Type = c(rep("RNA-seq",length(rna_seq_name)),rep("Microarray",length(microarray_name))))

```

# Subsetting objects
The major adavantage of using `SummarizedExperiment` and `MultiAssayExperiment` is the coordination of the meta-data and assays when subsetting.

## Subsetting for single objects
Both objects have similar method used for subsetting column information. 
```{r}
# subsetting samples from objects with TBStatus: PTB
GSE39939_sobject[, GSE39939_sobject$TBStatus == "PTB"]
```
```{r}
# subsetting samples from objects with TBStatus: PTB
GSE107991_mobject[, GSE107991_mobject$TBStatus == "PTB"]
```

## Subsetting for multiple objects 
Since not all datasets contain information about each TB status. Next we would like to select out all the samples with TBStatus=OD.
```{r}
# objects_list: a list that contains all the input data
objects_list_OD <-  lapply(objects_list, function(x) x[,x$TBStatus == "OD"])

# Define function removing empty objects
# should assign empty list with NA NOT NULL, because assigning NULL to list items, removes them...
remove_empty_object <- function(k){
  x <- k
  for (i in which(sapply(x, function(x) class(x) == "SummarizedExperiment"))){
    if(nrow(colData(x[[i]]))==0){
      x[[i]] <- NA
    }
  }
  for (j in which(sapply(x, function(x) class(x) == "MultiAssayExperiment"))){
    if(length(experiments(x[[j]]))==0){
      x[[j]] <- NA
    }
  }
  x <- x[!is.na(x)]
  return(x)
}

# Get a list of objects with TBStatus==OD
objects_list_OD <- remove_empty_object(objects_list_OD) 
```


# Normalization (Before match probeID to Gene symbol)
For imported expression datasets other than affymetrix microarray and GSEXXXXX, they are all non-normalized raw data. Next, we normalize microarray data using `normalizeBetweenArrays` from `limma` package , and normalize RNA-seq data using `TMM` from `edgeR` package.

## Between-sample normalization for Illumina microarray
```{r}
# add the normalized data as a new assay in the SummarizedExperiment 
# set all counts less than 0 to be 1
GSE39939_sobject_norm <- NormalizeReads(GSE39939_sobject, method = "quantile")
```
Boxplot for non-normalized microarray data
```{r, fig.height = 8, fig.width = 8}
boxplot(log(assays(GSE39939_sobject_norm)[["GSE39939_Non_normalized_counts"]][,1:20], base = 2))
# display the boxplot in log2
```
Boxplot for microarray data after quantile normalization
```{r, fig.height = 8, fig.width = 8}
boxplot(log(assays(GSE39939_sobject_norm)[["NormalizedReads"]][,1:20], base = 2))
# display the boxplot in log2
```

## Betwwen-sample normalization for RNA-seq

```{r}
# add the normalized data as a new assay in the MultiAssayExperiment 
GSE107991_mobject_norm <- NormalizeReads(GSE107991_mobject, experiment_type = "assay_raw", method = "TMM")
```

Boxplot for non-normalized RNA-seq data
```{r, fig.height = 8, fig.width = 8}
boxplot(log(assay(experiments(GSE107991_mobject_norm)[["assay_raw"]])[,1:20], base = 2))
# display the boxplot in log2
```

Boxplot for TMM normalized RNA-seq data
```{r, fig.height = 8, fig.width = 8}
boxplot(log(experiments(GSE107991_mobject_norm)[["assay_raw_norm"]][,1:20], base = 2))
# display the boxplot in log2
```

# Match ProbeID to Gene symbol
For objects that contain probe information, we match them to gene symbol. We collapse probe information by taking their mean values if they mapped to the same gene, and expand probe information for non-uniqueness mapping. In such cases, we use MultiAssayExperiment Objects to store information for each data.

## Create MultiAssayExperiment Object from SummarizedExperiment Object
```{r}
# Match Probe ID using raw data
MatchProbe(GSE39939_sobject, experiment_type = "assay_raw")
```

```{r}
# Match Probe ID using normalized data (if applicable)
MatchProbe(GSE39939_sobject_norm, experiment_type = "assay_raw_norm")
```

## Create MultiAssayExperiment Object from MultiAssayExperiment Object
```{r}
# Match Probe ID using raw data
MatchProbe(GSE107991_mobject, experiment_type = "assay_raw")
```

```{r}
# Match Probe ID using normalized data (if applicable)
MatchProbe(GSE107991_mobject_norm, experiment_type = "assay_raw_norm")
```


# TBSignature Analysis Using `TBSignatureProfiler`{.tabset}
```{r}
# Match ProbeID to Gene symbol for all existing datasets
multi_data_all <- lapply(objects_list, function(x) Create_MultiAssay_object(x))
```

## Positive TB (PTB) vs. Latent TB (Latent){.tabset}
```{r calculate ssgsea for PTB vs Latent, message = FALSE, results = "hide"}
multi_set_PTB_Latent <- lapply(multi_data_all, function(x) get_sobject_TBSig(x,"PTB","Latent")) %>% plyr::compact()

# 31 datasets contain information for PTB vs. Latent
ssgsea_PTB_Latent <- lapply(multi_set_PTB_Latent,
                    function(x) TBSignatureProfiler::runTBsigProfiler(input = x,
                                  useAssay = "counts",
                                  signatures = TBsignatures,
                                  algorithm = "ssGSEA",
                                  combineSigAndAlgorithm = TRUE,
                                  parallel.sz = 12))

# No Sloot_HIV_2, Suliman_RISK_4 in some datasets
TBsig_PTB_Latent <- names(TBsignatures)[-grep("Sloot_HIV_2|Suliman_RISK_4",names(TBsignatures))]

index_Sloot <- which(!sapply(ssgsea_PTB_Latent, function(x) "Sloot_HIV_2" %in% names(colData(x))))
index_Suliman <- which(!sapply(ssgsea_PTB_Latent, function(x) "Suliman_RISK_4" %in% names(colData(x))))
# Define new function for box plot display
get_boxplot <- function(result_list,sig_name){
  
  p_boxplot <- lapply(1:length(result_list), function(x)
    TBSignatureProfiler::signatureBoxplot(inputData = result_list[[x]],
                                      name = names(result_list)[x],
                                      signatureColNames = sig_name,
                                      annotationColName = "Disease", rotateLabels = FALSE,fill_colors = c("#4E84C4", "#FC4E07")))

    library(gridExtra)
    library(ggplot2)
    p_combine <- do.call("grid.arrange", c(p_boxplot, ncol=floor(sqrt(length(p_boxplot)))))
    return(p_combine)

}
```

### Boxplot of all scores signatures{.tabset}

```{r Boxplot for each signature PTB vs. Latent,results = "asis", message = FALSE, fig.height = 20, fig.width=28}
for (i in TBsig_PTB_Latent){

  cat("####", i, "\n")
  
  get_boxplot(ssgsea_PTB_Latent, sig_name = i)
  #print(signatureBoxplot(ssgsea_result, name = i, signatureColNames = i,
  #               annotationColName = c("Disease")))
  
  cat("\n\n")
}
```

#### Sloot_HIV_2

```{r boxplot for Sloot_HIV_2 PTB vs. Latent, results="hide",fig.height = 16, fig.width=24}
get_boxplot(ssgsea_PTB_Latent[-index_Sloot], sig_name = "Sloot_HIV_2")

```

#### Suliman_RISK_4

```{r boxplot for Suliman_RISK_4 PTB vs. Latent, results="hide",fig.height = 16, fig.width=24}
get_boxplot(ssgsea_PTB_Latent[-index_Suliman], sig_name = "Suliman_RISK_4")

```

# Train predictors using ensemble 
## Batch Correction

