---
title: "curatedTBData - Example"
author: "Xutao Wang"
output:
  BiocStyle::html_document:
    toc_float: true
  BiocStyle::pdf_document: default
package: BiocStyle
vignette: >
  %\VignetteIndexEntry{curatedTBData}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=TRUE, cache.lazy = FALSE, message=FALSE, warning=FALSE)
```

```{r install curatedTBData, eval = FALSE}
devtools::install_github("compbiomed/curatedTBData")
```

```{r libraries, message=FALSE}
library(BiocParallel)
library(dplyr)
library(edgeR)
library(ggplot2)
library(ggridges)
library(gridExtra)
library(limma)
library(MultiAssayExperiment)
library(SummarizedExperiment)
library(TBSignatureProfiler)

devtools::load_all()
library(curatedTBData)
```

This package requires large memory to process data. Please increase R script memory before running this vignette. \
See the post for details: [Increase memory for Macs](https://stackoverflow.com/questions/51295402/r-on-macos-error-vector-memory-exhausted-limit-reached)\
Step 1: Open terminal\
Step 2:
```{r, engine='bash', eval=FALSE}
cd ~
touch .Renviron
open .Renviron
```
Step 3: Save the following as the first line of .Renviron:
```{r, engine='bash', eval=FALSE}
R_MAX_VSIZE=50Gb 
```

# `curatedTBData`: Clinically Annotated Data for the Tuberculosis (TB) Transcriptome

## Load available SummarizedExperiment/MultiAssayExperiment Objects

We use `SummarizedExperiment` object to store information for microarray datasets, and use `MultiAssayExperiment` object to store information for RNA sequencing datasets. The pakcage function `get_curatedTBData` takes single or vector character string of GEO accession as input, and load the correpsonding curatedTBData in either the form of `SummarizedExperiment` or `MultiAssayExperiment`. 

```{r load a list of all datasets, results='hide'}
# To get a summary table for all the studies:
data("DataSummary",package="curatedTBData")

# Get a list of all data
objects_list <- get_curatedTBData(geo_access = "All")

# Load single data
# get_curatedTBData(geo_access = "GSE39939", include.SCAN = FALSE)

# Load Multiple Studies
# get_curatedTBData(geo_access = c("GSE54992","GSE107993"), 
#                  include.reprocess = TRUE)

```

## Load a list of RNA-seq data
```{r load a list of RNA-seq studies, results='hide', eval=FALSE}
# To get a summary table for all the studies:
data("DataSummary",package="curatedTBData")
geo_RNA_seq <- DataSummary %>% 
  dplyr::filter(stringr::str_detect(.data$GeneralType, "RNA-seq")) %>%
  dplyr::select(.data$`GEO accession`)
object_list_RNA_seq <- get_curatedTBData(
                             geo_access = geo_RNA_seq$`GEO accession`)
```

## Load a list of RNA-seq data
```{r load a list of microarray studies, results='hide', eval=FALSE}
geo_microarray <- DataSummary %>% 
  dplyr::filter(stringr::str_detect(.data$GeneralType, "Microarray")) %>%
  dplyr::select(.data$`GEO accession`)

object_list_microarray <- get_curatedTBData(
                             geo_access = geo_microarray$`GEO accession`)
```

# Subsetting Objects

The major adavantage of using `SummarizedExperiment` and `MultiAssayExperiment` is the coordination of the meta-data and assays when subsetting.
Both SummarizedExperiment and MultiAssayExperiment objects have similar buil-in fuction for subsetting samples based on column condition. For example, we want to select samples with only active TB, or with PTB or OD.
```{r subsetting single object example}
# subset samples from objects with TBStatus: PTB
GSE39939_sobject <- objects_list$GSE39939 # 157 samples
GSE39939_sobject[, GSE39939_sobject$TBStatus == "PTB"] # 79 samples
GSE39939_sobject[, GSE39939_sobject$TBStatus %in% c("PTB","OD")] # 143 samples

# Similar for MultiAssayExperiment object
GSE107991_mobject <- objects_list$GSE107991
GSE107991_mobject[, GSE107991_mobject$TBStatus == "PTB"]
```

# Normalization

For curatedTBData expression datasets except Affymetrix microarray and GSEXXXXX, they are all non-normalized raw data. Next, we normalize microarray data using `normalizeBetweenArrays` from `limma` package , and normalize RNA-seq data using `TMM` from `edgeR` package before matching probesets to gen symbol. 
Steps take: \
1. Set intensity values < 10 set to 10 \
2. log2 transformed the data. \
3. Normalize data using methods available in `edgeR` or `normalizeBetweenArrays`.

## Between-sample normalization for Illumina microarray

```{r}
# add the normalized data as a new assay in the SummarizedExperiment 
# set all counts less than 0 to be 1
GSE39939_sobject_norm <- Normalization(GSE39939_sobject, 
                                       microarray_method = "quantile")
```

Boxplot for non-normalized microarray data

```{r, fig.width = 8, fig.height = 8}
# display the boxplot in log2 for selected samples
boxplot(log(assays(GSE39939_sobject_norm)[[1]][,1:20], base=2))
```

Boxplot for microarray data after quantile normalization

```{r, fig.width = 8, fig.height = 8}
# display the boxplot in log2 for selected samples
boxplot(assays(GSE39939_sobject_norm)[["GSE39939_quantile"]][,1:20])

```

## Betwwen-sample normalization for RNA-seq

```{r}
# Add the normalized data as a new assay in the MultiAssayExperiment. 
# Use experiment_name = "assay_reprocess" for reprocess RNA-seq
GSE107991_mobject_norm <- Normalization(GSE107991_mobject, 
                                        RNAseq_method = "TMM", 
                                        experiment_name = "assay_raw")
```

Boxplot for non-normalized RNA-seq data
```{r, fig.width = 8, fig.height = 8}
# display the boxplot in log2
boxplot(log(assay(experiments(GSE107991_mobject_norm)[["assay_raw"]])
            [,1:20] + 0.0001, base = 2))
```

Boxplot for normalized RNA-seq data

```{r, fig.width = 8, fig.height = 8}
# display the boxplot in log2
# TMM reduces maximum value
boxplot(assays(experiments(GSE107991_mobject_norm)[["assay_raw"]])
        [["GSE107991_TMM"]][,1:20])
```

# Match Probe ID to Gene symbol

For objects that contain probe information, we match them to gene symbol. We collapse probe information by taking their mean values if they mapped to the same gene, and expand probe information for non-uniqueness mapping. In such cases, we use MultiAssayExperiment Objects to store information for each data.

```{r}
# Match Probe ID using raw data
# Specificy createExperimentName = "assay_raw_norm" for matching probe ID using normalized data (if applicable)
MatchProbe(GSE39939_sobject, UseAssay = "GSE39939_raw", 
           createExperimentName = "assay_MatchProbe")
MatchProbe(GSE107991_mobject, UseAssay = "GSE107991_raw", 
           createExperimentName = "assay_MatchProbe")
```

# Normalizing and mapping to a list of datasets

To start with, we create reate a list of object with normalized reads and probesets mapped to symbols. Matching probe sets to gene symbol using either raw data or normalized data (if applicable) .
Matching probes to symbol using raw data is straight-forward, we use the normalized data in the following.

```{r normalized/matched sample, cache=TRUE, results="hide"}
#Initialize parallel
param <- SerialParam(progressbar=TRUE)
# Normalization. For RNA-seq data, we use raw data from original for normalization (Not the self-processed dat) by specifying the experiment_name=assay_raw

object_norm <- bplapply(objects_list, function(x) 
  Normalization(x, microarray_method = "quantile", RNAseq_method = "TMM",
                experiment_name = "assay_raw"), BPPARAM = param) 

# Match Probe to gene symbols

# Use Assay specifying which assay to use, 
# No argument for experiemnt_name in MatchProbe, because assay_reprocess has mapped to gene symbol
# Reduce the runnning time using aggregate instead of dplyr
object_match1 <- bplapply(object_norm, function(x) 
  MatchProbe(x, UseAssay = c("TMM","quantile","RMA"),
             createExperimentName = "assay_MatchProbe"), BPPARAM = param)


# Remove samples with TBStatus == NA
object_match <- bplapply(object_match1, function(x) 
  x[,colData(x)[,"TBStatus"] != "NA"], BPPARAM = param)

# Import the list of TB signatures from TBSignatureProfiler
TBsignatures <- TBSignatureProfiler::TBsignatures
```

```{r, results="hide",include=FALSE, eval=FALSE}
#Initialize parallel
param <- SerialParam(progressbar=TRUE)

object_match1 <- readRDS("~/Desktop/object_match1.RDS")

# Remove samples with TBStatus == NA
object_match <- bplapply(object_match1, function(x) 
                            x[,colData(x)[,"TBStatus"]!= "NA"], BPPARAM = param)

# Define the list of TB signatures
TBsignatures <- TBSignatureProfiler::TBsignatures
```

# Datasets Integration

## Merge Studies with common gene symbols
If datasets are merged, it is typically recommended to remove a very likely batch effect. We will use the ComBat method, implemented for example in the SVA Bioconductor package. Start using `CombineObjects` to intersect objects with common gene symbol. This function produces a SummarizedExperiment object. GSE74092 is usually removed from merging, because this used quantitative PCR so they did not have enough coverage to capture all genes.

```{r merge datasets, results="hide", eval=FALSE}
# Merge all  microarray studies
geo_microarray <- DataSummary %>% dplyr::as_tibble() %>%
  dplyr::filter(stringr::str_detect(.data$GeneralType, "Microarray")) %>%
  dplyr::select(.data$`GEO accession`)

sobject <- CombineObjects(object_match1, 
                          list_name = geo_microarray$`GEO accession`, 
                          experiment_name = "assay_MatchProbe")

```

## Batch Correction
```{r batch correction, eval=FALSE, results='hide'}
# The samples that correspond to their datasets can be found at: colData(sobject)[,"GSE"]
# Batch correction
batch1 <- colData(sobject)$GSE

combat_edata1 <- sva::ComBat(dat = as.matrix(assay(sobject)), batch = batch1)
assays(sobject)[["Batch_corrected_counts"]] <- combat_edata1

# To separate batch-corrected object into separate SummarizedExperiment object list:
batch_sobject_list <- lapply(unique(colData(sobject)[,"GSE"]), 
                      function(x) {
                          index_GSE <- which(colData(sobject)$GSE %in% x)
                          sobject[,index_GSE]
})
names(batch_sobject_list) <- unique(colData(sobject)[,"GSE"])


# Create a table for sample and data source information with:
sample_data_info <- data.frame(Sample = row.names(colData(sobject)), 
                               Data = colData(sobject)[,"GSE"])

# Possible outcome of interest could be patient's TB subtypes, this can be found at: colData(sobject)[,"TBStatus"]

# Create a table for sample and TB status information with:
sample_outcome_info <- data.frame(Sample = row.names(colData(sobject)), 
                                  Data = colData(sobject)[,"TBStatus"])
```


# Active TB (PTB) vs. Latent TB (Latent) using `TBSignatureprofiler`

## ssGSEA {.tabset}

`TBSignatureprofiler` is a package to evaluate the the performance of signatures across curated TB data. We subset samples with PTB and Latent TB status for binary classification using function `subset_curatedTBData`, and implement single-sample Gene Set Enrichment Analysis (ssGSEA) scoring algorithm to compute gene scores for each signature.
Workflow of ssGSEA:\
1. Transform sample-specific gene expression value into absolute rank. For gene $i$ and sample $j$, the rank is: $|r_{ij}|$. **The list is then ordered from the highest rank to the lowest**. \

2. After getting the ranked data, calculate random walk statistics for each sample. 
$$v_{jk}(\ell) = \frac{\sum_{i=1}^\ell |r_{ij}|^\tau I(g(i)\in\gamma_k)}{\sum_{i=1}^p|r_{ij}|^\tau I(g(i)\in\gamma_k)}-\frac{\sum_{i=1}^\ell I(g(i)\notin \gamma_k)}{p-|\gamma_k|}, \quad\ell=1,\dots,p\\
                ES_{jk} =\sum_{\ell=1}^p v_{jk}(\ell)$$
$\tau=0.25$.\
$p=$ Total number of genes.\
$|\gamma_k|$= Number of genes within gene set $k$.\

3. Re-scale the enrichment scores (ES) for each sample
$$ES_{jk}=\frac{ES_{jk}}{\max\{ES_{1k},\dots,ES_{nk}\}-\min\{ES_{1k},\dots,ES_{nk}\}}$$

### Calculate ssGSEA

```{r calculate ssgsea for PTB vs Latent, cache=TRUE, results = "hide"}
# Select sample contain information about PTB and Latent
# Modify the list to make it compatible with TBSignatureProfiler

multi_set_PTB_Latent <- bplapply(object_match, function(x)
  subset_curatedTBData(x, annotationColName = "TBStatus", 
                       annotationCondition = c("Latent","PTB"), 
                       experiment_name = "assay_MatchProbe"), 
                       BPPARAM = param) %>% plyr::compact()   
# Remove empty objects use plyr::compact()

ssgsea_PTB_Latent <- lapply(multi_set_PTB_Latent,
                    function(x) TBSignatureProfiler::runTBsigProfiler(
                                  input = x,
                                  useAssay = assayNames(x),
                                  signatures = TBsignatures, 
                                  algorithm = "ssGSEA",
                                  combineSigAndAlgorithm = TRUE))


# Obtain p.value, AUC
ssgsea_PTB_Latent_combine <- combine_auc(ssgsea_PTB_Latent, 
                                annotationColName = "TBStatus", 
                                signatureColNames = names(TBsignatures), 
                                num.boot = 60, percent = 0.95)

# Obtain signature gene rank
# sig_list <- bplapply(ssgsea_PTB_Latent, function(x) get_gsea_rank(x, TBsignatures),BPPARAM=param)

# Filter TB signatures with genes less than or equal to 16
# TBsignatures_sub <- TBsignatures[lapply(TBsignatures, function(x) length(x)<=16) %>% unlist]
```

### Boxplot of all scores signatures{.tabset}

```{r Boxplot for each signature PTB vs. Latent, cache=TRUE, results = "asis", fig.width=30, fig.height = 32, fig.wide=TRUE}
for (i in names(TBsignatures)){

  cat("####", i, "\n")
  
  BoxplotTBSig(ssgsea_PTB_Latent, gset = i, annotationColName = "TBStatus")
  
  cat("\n\n")
}
```


```{r include = FALSE}
# Need this chunk to ensure the inclusion/embedding of DT required javascript to work 
DT::datatable(NULL)
```

### Table with T-tests & AUC{.tabset}

```{r Table for each signature PTB vs. Latent, cache=TRUE, results = "asis"}
for (i in names(TBsignatures)){

  cat("####", i, "\n")
  
  print(htmltools::tagList(DT::datatable(ssgsea_PTB_Latent_combine %>% dplyr::filter(.data$Signature == i) %>% dplyr::select(-.data$Signature))))
  
  cat("\n\n")
}
```

### Summary Table for the performance of each signature

Compute mean AUC and bootstrapped 95% CI

```{r summary table PTB vs. Latent}
# Seletct signatures and associated AUC
PTB_Latent_auc_summary_ssgsea <- ssgsea_PTB_Latent_combine %>% 
  dplyr::select(.data$Signature, AUC) %>% dplyr::group_split(.data$Signature)

# Get summarized table and bootstrap 95% Confidence Interval
ssgsea_PTB_Latent_auc_CI <- cbind(
  Signature=sapply(PTB_Latent_auc_summary_ssgsea, function(x) 
  x$Signature[1]), 
  do.call(rbind,lapply(PTB_Latent_auc_summary_ssgsea, function(x){
  bootstrap_mean_CI(x, colName="AUC", percent=0.95, num.boot=100)
}
)) 
)
ssgsea_PTB_Latent_auc_CI %>% DT::datatable()
```

### Comparison of Signature Performance using AUCs{.tabset}

#### Ridge Plot

```{r AUC ridge plot for PTB vs Latent, fig.width=8, fig.height = 15, cache=TRUE}
# Ridge plot for AUCs distribution across datasets
# PTB vs. Latent
get_auc_distribution(ssgsea_PTB_Latent_combine) + 
  ggtitle("Ridge plot of AUC for PTB vs. Latent") + 
  theme(axis.text.x = element_text(colour="Black", size=12, hjust = 0.5, 
                                   face="bold"),
        axis.text.y = element_text(size=12, angle = 0, hjust = 0.5))

```

#### Heatmap{.tabset}

##### With grouping

```{r PTB vs. Latent heatmap with grouping, fig.width=10, fig.height = 15, fig.wide=TRUE}
# Import signature and data information
heatmap_auc(ssgsea_PTB_Latent_combine, SignatureInfo, 
            names(TBsignatures), facet = TRUE) + 
  ggtitle("Heatmap of AUC for PTB vs. Latent")
```

## Select Patients with HIV Positive{.tabset}

### Subset and calculate ssGSEA
```{r PTB vs. Latent in HIV positive, results='hide'}
# Select objects with HIV information
object_match_HIV <- lapply(object_match, function(x)
  check_annotation(x, annotationColName = "HIVStatus", 
                   annotationCondition = "HIV positive")) %>% plyr::compact()

multi_set_PTB_Latent_HIV <- bplapply(object_match_HIV, function(x)
  subset_curatedTBData(x, annotationColName = "TBStatus", 
                       annotationCondition = c("Latent","PTB"), 
                       experiment_name = "assay_MatchProbe"), 
                       BPPARAM = param) %>% plyr::compact()   

ssgsea_PTB_Latent_HIV <- lapply(multi_set_PTB_Latent_HIV,
                    function(x) TBSignatureProfiler::runTBsigProfiler(
                                  input = x,
                                  useAssay = assayNames(x),
                                  signatures = TBsignatures, 
                                  algorithm = "ssGSEA",
                                  combineSigAndAlgorithm = TRUE))

# Obtain p.value, AUC
ssgsea_PTB_Latent_combine_HIV <- combine_auc(ssgsea_PTB_Latent_HIV, 
                                annotationColName = "TBStatus", 
                                signatureColNames = names(TBsignatures), 
                                num.boot = 60, percent = 0.95)

```

### Boxplot of all scores signatures{.tabset}

```{r Boxplot for each signature PTB vs. Latent in HIV positive, cache=TRUE, fig.wide = 5, fig.height = 8, results = "asis"}
for (i in names(TBsignatures)){

  cat("####", i, "\n")
  
  BoxplotTBSig(ssgsea_PTB_Latent_HIV, gset = i, annotationColName = "TBStatus")
  
  cat("\n\n")
}
```

```{r include = FALSE}
# Need this chunk to ensure the inclusion/embedding of DT required javascript to work 
DT::datatable(NULL)
```

### Table with T-tests & AUC{.tabset}

```{r Table for each signature PTB vs. Latent in HIV positive, cache=TRUE, results = "asis"}
for (i in names(TBsignatures)){

  cat("####", i, "\n")
  
  print(htmltools::tagList(DT::datatable(ssgsea_PTB_Latent_combine_HIV %>% 
                                           dplyr::filter(Signature == i) %>%
                                           dplyr::select(-Signature))))
  
  cat("\n\n")
}
```

### Summary Table for the performance of each signature

Compute mean AUC and bootstrapped 95% CI

```{r summary table PTB vs. Latent in HIV positive}
# Seletct signatures and associated AUC
PTB_Latent_auc_summary_ssgsea_HIV <- ssgsea_PTB_Latent_combine_HIV %>% 
  dplyr::select(Signature, AUC) %>% dplyr::group_split(Signature)

# Get summarized table and bootstrap 95% Confidence Interval
ssgsea_PTB_Latent_auc_CI_HIV <- cbind(
  Signature=sapply(PTB_Latent_auc_summary_ssgsea_HIV, function(x) 
  x$Signature[1]), 
  do.call(rbind,lapply(PTB_Latent_auc_summary_ssgsea_HIV, function(x){
  bootstrap_mean_CI(x, colName="AUC", percent=0.95, num.boot=100)
}
)) 
)
ssgsea_PTB_Latent_auc_CI_HIV %>% DT::datatable()
```

### Comparison of Signature Performance using AUCs{.tabset}

#### Heatmap
```{r PTB vs. Latent heatmap in HIV positive, fig.width=6, fig.height = 15, fig.wide=TRUE}
# Import signature and data information
heatmap_auc(ssgsea_PTB_Latent_combine_HIV, SignatureInfo, 
            names(TBsignatures), facet = TRUE) + 
  ggtitle("Heatmap of AUC for PTB vs. Latent")
```

## Select Patients with Diabetes Positive{.tabset}

### Subset and calculate ssGSEA

```{r PTB vs. Latent in Diabetes positive, results='hide'}
# Select objects with Diabetes Positive
object_match_DA <- lapply(object_match, function(x)
  check_annotation(x, annotationColName = "DiabetesStatus", 
                   annotationCondition = "Positive")) %>% plyr::compact()

multi_set_PTB_Latent_DA <- bplapply(object_match_DA, function(x)
  subset_curatedTBData(x, annotationColName = "TBStatus", 
                       annotationCondition = c("Latent","PTB"), 
                       experiment_name = "assay_MatchProbe"), 
                       BPPARAM = param) %>% plyr::compact()   

ssgsea_PTB_Latent_DA <- lapply(multi_set_PTB_Latent_DA,
                    function(x) TBSignatureProfiler::runTBsigProfiler(
                                  input = x,
                                  useAssay = assayNames(x),
                                  signatures = TBsignatures, 
                                  algorithm = "ssGSEA",
                                  combineSigAndAlgorithm = TRUE))


# Obtain p.value, AUC
ssgsea_PTB_Latent_combine_DA <- combine_auc(ssgsea_PTB_Latent_DA, 
                                annotationColName = "TBStatus", 
                                signatureColNames = names(TBsignatures), 
                                num.boot = 60, percent = 0.95)
```

### Boxplot of all scores signatures{.tabset}

```{r Boxplot for each signature PTB vs. Latent in Diabetes positive, cache=TRUE, fig.wide = 5, fig.height = 8, results = "asis"}
for (i in names(TBsignatures)){

  cat("####", i, "\n")
  
  BoxplotTBSig(ssgsea_PTB_Latent_DA, gset = i, annotationColName = "TBStatus")
  
  cat("\n\n")
}
```

```{r include = FALSE}
# Need this chunk to ensure the inclusion/embedding of DT required javascript to work 
DT::datatable(NULL)
```

### Table with T-tests & AUC{.tabset}

```{r Table for each signature PTB vs. Latent in Diabetes positive, cache=TRUE, results = "asis"}
for (i in names(TBsignatures)){

  cat("####", i, "\n")
  
  print(htmltools::tagList(DT::datatable(ssgsea_PTB_Latent_combine_DA %>% 
                                           dplyr::filter(Signature == i) %>%
                                           dplyr::select(-Signature))))
  
  cat("\n\n")
}
```

### Comparison of Signature Performance using AUCs{.tabset}

#### Heatmap
```{r PTB vs. Latent heatmap in Diabetes positive, fig.width=4, fig.height = 15, fig.wide=TRUE}
# Import signature and data information
heatmap_auc(ssgsea_PTB_Latent_combine_DA, SignatureInfo, 
            names(TBsignatures), facet = TRUE) + 
  ggtitle("Heatmap of AUC for PTB vs. Latent")
```

# Session Information
```{r session info}
sessionInfo()
```


